#include "GlobalShaderDeclarations.h"

#include <string>
#include <memory>

#include "Visual/Device/Compiler.h"
#include "Visual/Renderer/CachedHLSLShader.h"

#include "magic_enum/magic_enum.hpp"

namespace Renderer
{

	const char global_shader_declarations_DX11[] =	
		"#define CONCAT_HELPER( x, y ) x##y\n"
		"#define CONCAT( x, y ) CONCAT_HELPER( x, y )\n"
		"#define DX11\n"
		"#define PIXEL_RETURN_SEMANTIC SV_TARGET\n"
		"#define PIXEL_RETURN_SEMANTIC1 SV_TARGET1\n"
		"#define PIXEL_RETURN_SEMANTIC2 SV_TARGET2\n"
		"#define PIXEL_RETURN_SEMANTIC3 SV_TARGET3\n"
		"#define CBUFFER_BEGIN( name ) cbuffer name##{\n"
		"#define CBUFFER_END }\n"
		"#define SAMPLER_DECL( name ) SamplerState name\n"
		"#define SAMPLER_CMPDECL( name ) SamplerComparisonState name\n"
		"#define TEXTURE2D_DECL( name ) Texture2D name\n"
		"#define TEXTURE3D_DECL( name ) Texture3D name\n"
		"#define TEXTURECUBE_DECL( name ) TextureCube name\n"
		"#define TEXTURE2DMS_DECL( name, count ) Texture2DMS<float4, count> name\n"
		"#define SAMPLE_TEX_BIAS( tex, sampler, uv, mip_offset) tex.SampleBias(sampler, uv, mip_offset)\n"
		"#ifndef NO_MIPMAPS\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.Sample(sampler, uv)\n"
		"#else\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.SampleLevel(sampler, uv, -0.5f )\n"
		"#endif\n"
		"#define SAMPLE_TEX2DLOD( tex, sampler, uvw ) tex.SampleLevel(sampler, (uvw).xy, (uvw).w )\n"
		"#define SAMPLE_TEX3D( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEX3DLOD( tex, sampler, uvw ) tex.SampleLevel(sampler, uvw.xyz, uvw.w )\n"
		"#define SAMPLE_TEXCUBE( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEXCUBELOD( tex, sampler, uvzw ) tex.SampleLevel(sampler, (uvzw).xyz, (uvzw).w )\n"
		"#define SAMPLE_TEX2DGRAD( tex, sampler, uv, dx, dy ) tex.SampleGrad(sampler, uv, dx, dy )\n"
		"#define SAMPLE_TEX2DPROJ( tex, sampler, uvw ) tex.Sample(sampler, uvw.xy/uvw.w )\n"
		"#define SAMPLE_CMPLEVELZERO( tex, sampler, uvzw ) tex.SampleCmpLevelZero(sampler, uvzw.xy / uvzw.w, uvzw.z / uvzw.w)\n"
		"#define RWTEXTURE2D_DECL( name, type ) RWTexture2D<type> name\n"
		"#define STRUCTURED_BUFFER_DECL( name, type ) StructuredBuffer< type > name\n"
		"#define RWSTRUCTURED_BUFFER_DECL( name, type ) RWStructuredBuffer< type > name\n"
		"#define TEXEL_BUFFER_DECL( name, type ) Buffer< type > name\n"
		"#define RWTEXEL_BUFFER_DECL( name, type ) RWBuffer< type > name\n"
		"#define BYTE_ADDRESS_BUFFER_DECL( name ) ByteAddressBuffer name\n"
		"#define RWBYTE_ADDRESS_BUFFER_DECL( name ) RWByteAddressBuffer name\n"
		"#define COMPUTE_DECL_NUM_THREADS( X, Y, Z ) [numthreads(X, Y, Z)]\n"
		"#define ATOMIC_ADD( rsc, offset, value ) rsc.InterlockedAdd(offset, value)\n"
		"#define ATOMIC_FETCH_ADD( rsc, offset, value, oldValue ) rsc.InterlockedAdd(offset, value, oldValue)\n"
		"#define ATOMIC_SUB( rsc, offset, value ) rsc.InterlockedAdd(offset, -value)\n"
		"#define ATOMIC_FETCH_SUB( rsc, offset, value, oldValue ) rsc.InterlockedAdd(offset, -value, oldValue)\n"
		"#define ATOMIC_AND( rsc, offset, value ) rsc.InterlockedAnd(offset, value)\n"
		"#define ATOMIC_FETCH_AND( rsc, offset, value, oldValue ) rsc.InterlockedAnd(offset, value, oldValue)\n"
		"#define ATOMIC_OR( rsc, offset, value ) rsc.InterlockedOr(offset, value)\n"
		"#define ATOMIC_FETCH_OR( rsc, offset, value, oldValue ) rsc.InterlockedOr(offset, value, oldValue)\n"
		"#define ATOMIC_XOR( rsc, offset, value ) rsc.InterlockedXor(offset, value)\n"
		"#define ATOMIC_FETCH_XOR( rsc, offset, value, oldValue ) rsc.InterlockedXor(offset, value, oldValue)\n"
		"#define ATOMIC_MIN( rsc, offset, value ) rsc.InterlockedMin(offset, value)\n"
		"#define ATOMIC_FETCH_MIN( rsc, offset, value, oldValue ) rsc.InterlockedMin(offset, value, oldValue)\n"
		"#define ATOMIC_MAX( rsc, offset, value ) rsc.InterlockedMax(offset, value)\n"
		"#define ATOMIC_FETCH_MAX( rsc, offset, value, oldValue ) rsc.InterlockedMax(offset, value, oldValue)\n"
		"#define ATOMIC_EXCHANGE( rsc, offset, value, oldValue ) rsc.InterlockedExchange(offset, value, oldValue)\n"
		"#define ATOMIC_CMP_STORE( rsc, offset, cmp, value ) rsc.InterlockedCompareStore(offset, cmp, value)\n"
		"#define ATOMIC_CMP_EXCHANGE( rsc, offset, cmp, value, oldValue ) rsc.InterlockedCompareExchange(offset, cmp, value, oldValue)\n"
		"#define MEMORY_BARRIER_ALL AllMemoryBarrierWithGroupSync\n"
		"#define MEMORY_BARRIER_DEVICE DeviceMemoryBarrierWithGroupSync\n"
		"#define MEMORY_BARRIER_GROUP GroupMemoryBarrierWithGroupSync\n"
		"#include \"Shaders/SamplerDeclarations.inc\"\n"
		"#include \"Shaders/CommonDeclarations.inc\"\n"
		;

	const char global_shader_declarations_DX12[] =
		"#define CONCAT_HELPER( x, y ) x##y\n"
		"#define CONCAT( x, y ) CONCAT_HELPER( x, y )\n"
		"#define DX12\n"
		"#define PIXEL_RETURN_SEMANTIC SV_TARGET\n"
		"#define PIXEL_RETURN_SEMANTIC1 SV_TARGET1\n"
		"#define PIXEL_RETURN_SEMANTIC2 SV_TARGET2\n"
		"#define PIXEL_RETURN_SEMANTIC3 SV_TARGET3\n"
		"#define CBUFFER_BEGIN( name ) cbuffer name {\n"
		"#define CBUFFER_END }\n"
		"#define SAMPLER_DECL( name ) SamplerState name\n"
		"#define SAMPLER_CMPDECL( name ) SamplerComparisonState name\n"
		"#define TEXTURE2D_DECL( name ) Texture2D name\n"
		"#define TEXTURE3D_DECL( name ) Texture3D name\n"
		"#define TEXTURECUBE_DECL( name ) TextureCube name\n"
		"#define TEXTURE2DMS_DECL( name, count ) Texture2DMS<float4, count> name\n"
		"#define SAMPLE_TEX_BIAS( tex, sampler, uv, mip_offset) tex.SampleBias(sampler, uv, mip_offset)\n"
		"#ifndef NO_MIPMAPS\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.Sample(sampler, uv)\n"
		"#else\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.SampleLevel(sampler, uv, -0.5f )\n"
		"#endif\n"
		"#define SAMPLE_TEX2DLOD( tex, sampler, uvw ) tex.SampleLevel(sampler, (uvw).xy, (uvw).w )\n"
		"#define SAMPLE_TEX3D( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEX3DLOD( tex, sampler, uvw ) tex.SampleLevel(sampler, uvw.xyz, uvw.w )\n"
		"#define SAMPLE_TEXCUBE( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEXCUBELOD( tex, sampler, uvzw ) tex.SampleLevel(sampler, (uvzw).xyz, (uvzw).w )\n"
		"#define SAMPLE_TEX2DGRAD( tex, sampler, uv, dx, dy ) tex.SampleGrad(sampler, uv, dx, dy )\n"
		"#define SAMPLE_TEX2DPROJ( tex, sampler, uvw ) tex.Sample(sampler, uvw.xy/uvw.w )\n"
		"#define SAMPLE_CMPLEVELZERO( tex, sampler, uvzw ) tex.SampleCmpLevelZero(sampler, uvzw.xy / uvzw.w, uvzw.z / uvzw.w)\n"
		"#define RWTEXTURE2D_DECL( name, type ) RWTexture2D<type> name\n"
		"#define STRUCTURED_BUFFER_DECL( name, type ) StructuredBuffer< type > name\n"
		"#define RWSTRUCTURED_BUFFER_DECL( name, type ) RWStructuredBuffer< type > name\n"
		"#define TEXEL_BUFFER_DECL( name, type ) Buffer< type > name\n"
		"#define RWTEXEL_BUFFER_DECL( name, type ) RWBuffer< type > name\n"
		"#define BYTE_ADDRESS_BUFFER_DECL( name ) ByteAddressBuffer name\n"
		"#define RWBYTE_ADDRESS_BUFFER_DECL( name ) RWByteAddressBuffer name\n"
		"#define COMPUTE_DECL_NUM_THREADS( X, Y, Z ) [numthreads(X, Y, Z)]\n"
		"#define ATOMIC_ADD( rsc, offset, value ) rsc.InterlockedAdd(offset, value)\n"
		"#define ATOMIC_FETCH_ADD( rsc, offset, value, oldValue ) rsc.InterlockedAdd(offset, value, oldValue)\n"
		"#define ATOMIC_SUB( rsc, offset, value ) rsc.InterlockedAdd(offset, -value)\n"
		"#define ATOMIC_FETCH_SUB( rsc, offset, value, oldValue ) rsc.InterlockedAdd(offset, -value, oldValue)\n"
		"#define ATOMIC_AND( rsc, offset, value ) rsc.InterlockedAnd(offset, value)\n"
		"#define ATOMIC_FETCH_AND( rsc, offset, value, oldValue ) rsc.InterlockedAnd(offset, value, oldValue)\n"
		"#define ATOMIC_OR( rsc, offset, value ) rsc.InterlockedOr(offset, value)\n"
		"#define ATOMIC_FETCH_OR( rsc, offset, value, oldValue ) rsc.InterlockedOr(offset, value, oldValue)\n"
		"#define ATOMIC_XOR( rsc, offset, value ) rsc.InterlockedXor(offset, value)\n"
		"#define ATOMIC_FETCH_XOR( rsc, offset, value, oldValue ) rsc.InterlockedXor(offset, value, oldValue)\n"
		"#define ATOMIC_MIN( rsc, offset, value ) rsc.InterlockedMin(offset, value)\n"
		"#define ATOMIC_FETCH_MIN( rsc, offset, value, oldValue ) rsc.InterlockedMin(offset, value, oldValue)\n"
		"#define ATOMIC_MAX( rsc, offset, value ) rsc.InterlockedMax(offset, value)\n"
		"#define ATOMIC_FETCH_MAX( rsc, offset, value, oldValue ) rsc.InterlockedMax(offset, value, oldValue)\n"
		"#define ATOMIC_EXCHANGE( rsc, offset, value, oldValue ) rsc.InterlockedExchange(offset, value, oldValue)\n"
		"#define ATOMIC_CMP_STORE( rsc, offset, cmp, value ) rsc.InterlockedCompareStore(offset, cmp, value)\n"
		"#define ATOMIC_CMP_EXCHANGE( rsc, offset, cmp, value, oldValue ) rsc.InterlockedCompareExchange(offset, cmp, value, oldValue)\n"
		"#define MEMORY_BARRIER_ALL AllMemoryBarrierWithGroupSync\n"
		"#define MEMORY_BARRIER_DEVICE DeviceMemoryBarrierWithGroupSync\n"
		"#define MEMORY_BARRIER_GROUP GroupMemoryBarrierWithGroupSync\n"
		"#include \"Shaders/SamplerDeclarations.inc\"\n"
		"#include \"Shaders/CommonDeclarations.inc\"\n"
		;

	const char global_shader_declarations_GNMX[] =
		"#define CONCAT_HELPER( x, y ) x##y\n"
		"#define CONCAT( x, y ) CONCAT_HELPER( x, y )\n"
		"#define GNMX\n"
		"#define PIXEL_RETURN_SEMANTIC S_TARGET_OUTPUT\n"
		"#define PIXEL_RETURN_SEMANTIC1 S_TARGET_OUTPUT1\n"
		"#define PIXEL_RETURN_SEMANTIC2 S_TARGET_OUTPUT2\n"
		"#define PIXEL_RETURN_SEMANTIC3 S_TARGET_OUTPUT3\n"
		"#define SV_POSITION S_POSITION\n"
		"#define SV_DEPTH S_DEPTH_OUTPUT\n"
		"#define SV_VertexID S_VERTEX_ID\n"
		"#define SV_InstanceID S_INSTANCE_ID\n"
		"#define SV_PrimitiveID S_PRIMITIVE_ID\n"
		"#define SV_GroupThreadID S_GROUP_THREAD_ID\n"
		"#define SV_GroupID S_GROUP_ID\n"
		"#define SV_GroupIndex S_GROUP_INDEX\n"
		"#define SV_DispatchThreadID S_DISPATCH_THREAD_ID\n"
		"#define CBUFFER_BEGIN( name ) ConstantBuffer name##{\n"
		"#define CBUFFER_END }\n"
		"#define SAMPLER_DECL( name ) SamplerState name\n"
		"#define SAMPLER_CMPDECL( name ) SamplerComparisonState name\n"
		"#define TEXTURE2D_DECL( name ) Texture2D name\n"
		"#define TEXTURE3D_DECL( name ) Texture3D name\n"
		"#define TEXTURECUBE_DECL( name ) TextureCube name\n"
		"#define TEXTURE2DMS_DECL( name, count ) MS_Texture2D<float4> name\n"
		"#define SAMPLE_TEX_BIAS( tex, sampler, uv, mip_offset) tex.SampleBias(sampler, uv, mip_offset)\n"
		"#ifndef NO_MIPMAPS\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.Sample(sampler, uv)\n"
		"#else\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.SampleLOD(sampler, uv, -0.5f )\n"
		"#endif\n"
		"#define SAMPLE_TEX2DLOD( tex, sampler, uvw ) tex.SampleLOD(sampler, (uvw).xy, (uvw).w )\n"
		"#define SAMPLE_TEX3D( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEX3DLOD( tex, sampler, uvw ) tex.SampleLOD(sampler, uvw.xyz, uvw.w )\n"
		"#define SAMPLE_TEXCUBE( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEXCUBELOD( tex, sampler, uvzw ) tex.SampleLOD(sampler, (uvzw).xyz, (uvzw).w )\n"
		"#define SAMPLE_TEX2DGRAD( tex, sampler, uv, dx, dy ) tex.SampleGradient(sampler, uv, dx, dy )\n"
		"#define SAMPLE_TEX2DPROJ( tex, sampler, uvw ) tex.Sample(sampler, uvw.xy/uvw.w )\n"
		"#define SAMPLE_CMPLEVELZERO( tex, sampler, uvzw ) tex.SampleCmpLOD0(sampler, uvzw.xy / uvzw.w, uvzw.z / uvzw.w)\n"
		"#define RWTEXTURE2D_DECL( name, type ) RW_Texture2D<type> name\n"
		"#define STRUCTURED_BUFFER_DECL( name, type ) RegularBuffer< type > name\n"
		"#define RWSTRUCTURED_BUFFER_DECL( name, type ) RW_RegularBuffer< type > name\n"
		"#define TEXEL_BUFFER_DECL( name, type ) DataBuffer< type > name\n"
		"#define RWTEXEL_BUFFER_DECL( name, type ) RW_DataBuffer< type > name\n"
		"#define BYTE_ADDRESS_BUFFER_DECL( name ) ByteBuffer name\n"
		"#define RWBYTE_ADDRESS_BUFFER_DECL( name ) RW_ByteBuffer name\n"
		"#define COMPUTE_DECL_NUM_THREADS( X, Y, Z ) [NUM_THREADS(X, Y, Z)]\n"
		"#define ATOMIC_ADD( rsc, offset, value ) rsc.AtomicAdd(offset, value)\n"
		"#define ATOMIC_FETCH_ADD( rsc, offset, value, oldValue ) rsc.AtomicAdd(offset, value, oldValue)\n"
		"#define ATOMIC_SUB( rsc, offset, value ) rsc.AtomicAdd(offset, -value)\n"
		"#define ATOMIC_FETCH_SUB( rsc, offset, value, oldValue ) rsc.AtomicAdd(offset, -value, oldValue)\n"
		"#define ATOMIC_AND( rsc, offset, value ) rsc.AtomicAnd(offset, value)\n"
		"#define ATOMIC_FETCH_AND( rsc, offset, value, oldValue ) rsc.AtomicAnd(offset, value, oldValue)\n"
		"#define ATOMIC_OR( rsc, offset, value ) rsc.AtomicOr(offset, value)\n"
		"#define ATOMIC_FETCH_OR( rsc, offset, value, oldValue ) rsc.AtomicOr(offset, value, oldValue)\n"
		"#define ATOMIC_XOR( rsc, offset, value ) rsc.AtomicXor(offset, value)\n"
		"#define ATOMIC_FETCH_XOR( rsc, offset, value, oldValue ) rsc.AtomicXor(offset, value, oldValue)\n"
		"#define ATOMIC_MIN( rsc, offset, value ) rsc.AtomicMin(offset, value)\n"
		"#define ATOMIC_FETCH_MIN( rsc, offset, value, oldValue ) rsc.AtomicMin(offset, value, oldValue)\n"
		"#define ATOMIC_MAX( rsc, offset, value ) rsc.AtomicMax(offset, value)\n"
		"#define ATOMIC_FETCH_MAX( rsc, offset, value, oldValue ) rsc.AtomicMax(offset, value, oldValue)\n"
		"#define ATOMIC_EXCHANGE( rsc, offset, value, oldValue ) rsc.AtomicExchange(offset, value, oldValue)\n"
		"#define ATOMIC_CMP_STORE( rsc, offset, cmp, value ) rsc.AtomicCmpStore(offset, cmp, value)\n"
		"#define ATOMIC_CMP_EXCHANGE( rsc, offset, cmp, value, oldValue ) rsc.AtomicCmpExchange(offset, cmp, value, oldValue)\n"
		"#define MEMORY_BARRIER_ALL MemoryBarrier\n"
		"#define MEMORY_BARRIER_DEVICE SystemMemoryBarrier\n"
		"#define MEMORY_BARRIER_GROUP ThreadGroupMemoryBarrier\n"
		"#include \"Shaders/SamplerDeclarations.inc\"\n"
		"#include \"Shaders/CommonDeclarations.inc\"\n"
		;

	const char global_shader_declarations_Vulkan[] =
		"#define CONCAT_HELPER( x, y ) x##y\n"
		"#define CONCAT( x, y ) CONCAT_HELPER( x, y )\n"
		"#define VULKAN\n"
		"#define PIXEL_RETURN_SEMANTIC SV_TARGET\n"
		"#define PIXEL_RETURN_SEMANTIC1 SV_TARGET1\n"
		"#define PIXEL_RETURN_SEMANTIC2 SV_TARGET2\n"
		"#define PIXEL_RETURN_SEMANTIC3 SV_TARGET3\n"
		"#define CBUFFER_BEGIN( name ) cbuffer name##_cb {\n"
		"#define CBUFFER_END }\n"
		"#define SAMPLER_DECL( name ) SamplerState name\n"
		"#define SAMPLER_CMPDECL( name ) SamplerComparisonState name\n"
		"#define TEXTURE2D_DECL( name ) Texture2D name\n"
		"#define TEXTURE3D_DECL( name ) Texture3D name\n"
		"#define TEXTURECUBE_DECL( name ) TextureCube name\n"
		"#define TEXTURE2DMS_DECL( name, count ) Texture2DMS<float4, count> name\n"
		"#define SAMPLE_TEX_BIAS( tex, sampler, uv, mip_offset) tex.SampleBias(sampler, uv, mip_offset)\n"
		"#ifndef NO_MIPMAPS\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.Sample(sampler, uv)\n"
		"#else\n"
		"	#define SAMPLE_TEX2D( tex, sampler, uv ) tex.SampleLevel(sampler, uv, -0.5f )\n"
		"#endif\n"
		"#define SAMPLE_TEX2DLOD( tex, sampler, uvw ) tex.SampleLevel(sampler, (uvw).xy, (uvw).w )\n"
		"#define SAMPLE_TEX3D( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEX3DLOD( tex, sampler, uvw ) tex.SampleLevel(sampler, uvw.xyz, uvw.w )\n"
		"#define SAMPLE_TEXCUBE( tex, sampler, uvw ) tex.Sample(sampler, uvw)\n"
		"#define SAMPLE_TEXCUBELOD( tex, sampler, uvzw ) tex.SampleLevel(sampler, (uvzw).xyz, (uvzw).w )\n"
		"#define SAMPLE_TEX2DGRAD( tex, sampler, uv, dx, dy ) tex.SampleGrad(sampler, uv, dx, dy )\n"
		"#define SAMPLE_TEX2DPROJ( tex, sampler, uvw ) tex.Sample(sampler, uvw.xy/uvw.w )\n"
		"#define SAMPLE_CMPLEVELZERO( tex, sampler, uvzw ) tex.SampleCmpLevelZero(sampler, uvzw.xy / uvzw.w, uvzw.z / uvzw.w)\n"
		"#define RWTEXTURE2D_DECL( name, type ) RWTexture2D<type> name\n"
		"#define STRUCTURED_BUFFER_DECL( name, type ) StructuredBuffer< type > name\n"
		"#define RWSTRUCTURED_BUFFER_DECL( name, type ) RWStructuredBuffer< type > name\n"
		"#define TEXEL_BUFFER_DECL( name, type ) Buffer< type > name\n"
		"#define RWTEXEL_BUFFER_DECL( name, type ) RWBuffer< type > name\n"
		"#define BYTE_ADDRESS_BUFFER_DECL( name ) ByteAddressBuffer name\n"
		"#define RWBYTE_ADDRESS_BUFFER_DECL( name ) RWByteAddressBuffer name\n"
		"#define COMPUTE_DECL_NUM_THREADS( X, Y, Z ) [numthreads(X, Y, Z)]\n"
		"#define ATOMIC_ADD( rsc, offset, value ) rsc.InterlockedAdd(offset, value)\n"
		"#define ATOMIC_FETCH_ADD( rsc, offset, value, oldValue ) rsc.InterlockedAdd(offset, value, oldValue)\n"
		"#define ATOMIC_SUB( rsc, offset, value ) rsc.InterlockedAdd(offset, -value)\n"
		"#define ATOMIC_FETCH_SUB( rsc, offset, value, oldValue ) rsc.InterlockedAdd(offset, -value, oldValue)\n"
		"#define ATOMIC_AND( rsc, offset, value ) rsc.InterlockedAnd(offset, value)\n"
		"#define ATOMIC_FETCH_AND( rsc, offset, value, oldValue ) rsc.InterlockedAnd(offset, value, oldValue)\n"
		"#define ATOMIC_OR( rsc, offset, value ) rsc.InterlockedOr(offset, value)\n"
		"#define ATOMIC_FETCH_OR( rsc, offset, value, oldValue ) rsc.InterlockedOr(offset, value, oldValue)\n"
		"#define ATOMIC_XOR( rsc, offset, value ) rsc.InterlockedXor(offset, value)\n"
		"#define ATOMIC_FETCH_XOR( rsc, offset, value, oldValue ) rsc.InterlockedXor(offset, value, oldValue)\n"
		"#define ATOMIC_MIN( rsc, offset, value ) rsc.InterlockedMin(offset, value)\n"
		"#define ATOMIC_FETCH_MIN( rsc, offset, value, oldValue ) rsc.InterlockedMin(offset, value, oldValue)\n"
		"#define ATOMIC_MAX( rsc, offset, value ) rsc.InterlockedMax(offset, value)\n"
		"#define ATOMIC_FETCH_MAX( rsc, offset, value, oldValue ) rsc.InterlockedMax(offset, value, oldValue)\n"
		"#define ATOMIC_EXCHANGE( rsc, offset, value, oldValue ) rsc.InterlockedExchange(offset, value, oldValue)\n"
		"#define ATOMIC_CMP_STORE( rsc, offset, cmp, value ) rsc.InterlockedCompareStore(offset, cmp, value)\n"
		"#define ATOMIC_CMP_EXCHANGE( rsc, offset, cmp, value, oldValue ) rsc.InterlockedCompareExchange(offset, cmp, value, oldValue)\n"
		"#define MEMORY_BARRIER_ALL AllMemoryBarrierWithGroupSync\n"
		"#define MEMORY_BARRIER_DEVICE DeviceMemoryBarrierWithGroupSync\n"
		"#define MEMORY_BARRIER_GROUP GroupMemoryBarrierWithGroupSync\n"
		"#include \"Shaders/SamplerDeclarations.inc\"\n"
		"#include \"Shaders/CommonDeclarations.inc\"\n"
		;

	const char global_shader_declarations_Null[] = "";


	namespace
	{
		std::array<std::array<unsigned char, File::SHA256::Length>, magic_enum::enum_count<Device::Target>()> hashes;
		bool hashes_initialized = false;
	}

	const std::array<unsigned char, File::SHA256::Length>& GetGlobalDeclarationHash(const Device::Target& target)
	{
		assert(hashes_initialized);
		return hashes[(size_t)target];
	}

	void SetupGlobalDeclarationHashes()
	{
		hashes_initialized = true;
		for (int i = 0; i < (int)magic_enum::enum_count<Device::Target>(); i++)
			hashes[i] = GetShaderIncludesHash(GetGlobalDeclaration((Device::Target)i));
	}

	const char* GetGlobalDeclaration(const Device::Target& target)
	{
		switch (target)
		{
		case Device::Target::D3D11: return global_shader_declarations_DX11;
		case Device::Target::D3D12: return global_shader_declarations_DX12;
		case Device::Target::GNM: return global_shader_declarations_GNMX;
		case Device::Target::Vulkan: return global_shader_declarations_Vulkan;
		case Device::Target::Null: return global_shader_declarations_Null;
		default: throw std::runtime_error("Unsupported");
		}
	}
}
