/* SIE CONFIDENTIAL
PlayStation(R)4 Programmer Tool Runtime Library Release 08.508.001
* Copyright (C) 2015 Sony Interactive Entertainment Inc.
*/

#ifndef _SCE_SHADER_BINARY_H
#define _SCE_SHADER_BINARY_H

#include <shader/pssl_types.h>

/*
 * Error number definition
 */

/**
 * @j 不正なメモリアドレスが指定された @ej
 * @e Specified memory address is invalid @ee
 */
#define SCE_SHADER_BINARY_ERROR_INVALID_ADDR	-2137980927	/* 0x80910001 */

/**
 * @j 不正なメモリサイズが指定された @ej
 * @e Specified memory size is invalid @ee
 */
#define SCE_SHADER_BINARY_ERROR_INVALID_SIZE	-2137980926	/* 0x80910002 */


/*
 * End of error number definition generated by binary_error_gen.bat
 */

namespace sce
{
/// The Shader namespace contains shader material.
namespace Shader
{
/// The Binary namespace contains shader binary material.
namespace Binary
{

#if !defined(DOXYGEN_IGNORE)
// Shader Binary Format version number (0.4)
const uint8_t kFormatVersionMajor = 0; // The major version number.
const uint8_t kFormatVersionMinor = 4; // The minor version number.

// 0.3 (SDK 2.000 and before)
// 0.4 (SDK 2.500)
//		- Allocated padding bits to new Header::m_compilerType field.
//      - Allocated next bit of Element::m_isUsed to m_isRowMajor to indicate row_major qualifier on matrix types.
//		- Reserved remaining upper bits of Element::m_isUsed and m_isPointer boolean values for future use.
#endif // !defined(DOXYGEN_IGNORE)

/** Represents a shader binary attribute.

	An attribute in the shader is either an input or output variable with an associated semantic.
	This class defines how information about an attribute is stored in the shader binary.
*/
class Attribute
{
public:
	uint8_t		m_type;               ///< The <c>PsslType</c> such as <c>kTypeFloat4</c>, <c>kTypeFloat1x3</c>, etc. 
	uint8_t		m_psslSemantic;       ///< The <c>PsslSemantic</c> such as <c>kSemanticPosition</c>, <c>kSemanticSClipDistance</c>, etc.
	uint8_t		m_semanticIndex;      ///< An optional index of the semantic such as <c>S_TARGET_OUTPUT[0,1,...]</c>. By default this is set to 0.
	uint8_t		m_resourceIndex;      ///< The actual hardware resource.  The maximum for pixel output is 8; otherwise the maximum is 32 for all other input/output resources.

	uint8_t		m_interpType;         ///< The <c>PsslFragmentInterpType</c>. This is only used for the Pixel Shader stage. 
	uint8_t		m_streamNumber;       ///< The stream out buffer using the Geometry Shader Stream out. 
	uint8_t		m_paddingTo32[2];     ///< Padding.

	uint32_t	m_nameOffset;         ///< The offset for the name of this attribute in the name string table.
	uint32_t	m_semanticNameOffset; ///< The offset for the name of this attribute's semantic into name string table.

	/// Gets the name of this attribute.
	///
	///	@return The name of this attribute.
	const char *getName() const { return ((const char*)&m_nameOffset) + m_nameOffset; }
	
	/// Gets the name of this attribute's semantic.
	///
	///	@return The name of this attribute's semantic.
	const char *getSemanticName() const { return ((const char*)&m_semanticNameOffset) + m_semanticNameOffset; }
};

/** Represents the shader binary constant (STRUCT IS DEPRECATED; Please use Element instead). 
	
	This was used to store flattened constant elements. 
*/
class Constant
{
public:
	uint32_t	m_elementOffset;       ///< The element offset from the start of this constant resource.  This will only be non-zero in the case of packed constant.	
	uint32_t	m_registerIndex;       ///< The register index of the constant buffer as specified in the shader source. (e.g. <c>cb0[0]</c>, <c>cb0[1]</c>, ...)	
	uint8_t		m_constantBufferIndex; ///< The constant buffer index as specified in the shader source.  (e.g. <c>cb0</c>, <c>cb1</c>, ...)
	uint8_t		m_elementType;         ///< The <c>PsslType</c> such as <c>kTypeFloat4</c>, <c>kTypeFloat1x3</c>, etc. 
	uint8_t		m_bufferType;          ///< The <c>PsslBufferType</c> such as <c>kBufferTypeConstantBuffer</c>, <c>kBufferTypeTextureBuffer</c>, etc.  	
	uint8_t		m_paddingTo32;         ///< Padding.

	///	The default values.
	///
	/// If the element type is either a uint or int variation, values will be stored as a native word (uint).
	union
	{
		float		m_f[4];	           ///< The default float values if they were specified in the shader source. For example, <c>float4 lightPos = float4(10.0,3.0,-2.0,0.0);</c>	
		uint32_t	m_ui[4];           ///< The default uint values if they were specified in the shader source. For example, <c>uint4 lightPos = uint4(10,3,-2,0);</c>	
	} m_defaultValues;                 ///< Either the float or uint default values depending on what was specified in the shader source. 

	uint32_t	m_nameOffset;          ///< The offset for the name of this binary constant in the name string table.

	/// Gets the name of this binary constant.
	///
	///	@return The name of this binary constant.
	const char *getName() const { return ((const char*)&m_nameOffset) + m_nameOffset; }
};

///	Defines the different types of element.
typedef enum PsslElementType
{
    kPsslElement                = 0,	///< A standard structure element.	   
    kPsslBufferElement          = 1,	///< A buffer element.
    kPsslSamplerStateElement    = 2,	///< A sampler state element.
	kPsslConstantBufferElement  = 3,	///< A constant in a constant buffer, with default value.
} PsslElementType;

/** Represents the shader binary element.

	This class represents an element in the constant buffer or regular buffer template type.
	When a constant buffer or regular buffer template type has a hierarchical data structure, 
	the tree-like data structure is encoded into the shader binary as list of elements.
	The class contains a nested union which represents the element's default value. This is either
	an offset to the default value in a value table or an index into a list of buffers depending
	of whether the element is a buffer element.
*/
class Element
{
public:
	uint8_t     m_type;                ///< The <c>PsslType</c> such as <c>kTypeFloat4</c>, <c>kTypeFloat1x3</c>, etc. 
	uint8_t     m_isUsed          : 1; ///< A flag which specifies if an element is used or not. A value of 1 indicates that it is used; 0 indicates that it is not.
	uint8_t     m_isRowMajor      : 1; ///< A flag which specifies if an element of matrix type is stored in row_major order (1) or column_major order (0).
	uint8_t     m_reserved_b10_15 : 6; // 0; reserved for future use
	uint8_t     m_isPointer       : 1; ///< A flag which specifies if the element is an 8-byte pointer to type m_type (1) or a value of type m_type (0)
	uint8_t     m_reserved_b17_23 : 7; // 0; reserved for future use
	uint8_t     m_elementType;		   ///< The element type <c><i>m_type</i></c> represents. This should be a value defined by PsslElementType. 
	uint32_t    m_byteOffset;          ///< The byte offset of this element in the parent resource.
	uint32_t    m_size;                ///< The size in bytes of this element.
	uint32_t    m_arraySize;           ///< The size of the array. This member is set to 0 if the element is not an array.
	
	///	The default values.
	union
	{
		uint32_t m_defaultValueOffset; ///< The DWORD offset to the default value in the value table. This is set to 0xFFFFFFFF if there is none.
		uint32_t m_resourceIndex;      ///< The index into the list of buffers in the case of a buffer element. 
	};

	// for structure 
	uint32_t    m_numElements;         ///< The number of member elements in the structure. A value of 0 indicates this is basic-type structure.
	uint32_t    m_elementOffset;       ///< The shader binary offset to the beginning of the member elements in the elements block. This is set to 0xFFFFFFFF if there are none.

	uint32_t	m_nameOffset;          ///< The offset for the name of this element in the name string table.
	uint32_t	m_typeNameOffset;      ///< The offset for the name of this element's type in the name string table.

	/// Gets the name of this binary element.
	///
	///	@return The name of this binary element.
	const char *getName() const { return ((const char*)&m_nameOffset) + m_nameOffset; }

	/// Gets the name of this binary element's type.
	///
	///	@return The name of this binary element's type.
	const char *getTypeName() const { return ((const char*)&m_typeNameOffset) + m_typeNameOffset; }
};

/** Represents the shader binary buffer.

    This class is used for all input resources including constant buffers and textures.
*/
class Buffer
{
public:
	uint32_t    m_resourceIndex;   ///< The resource ID for this buffer type.  (e.g. <c>SRV: t0,t1,...  UAV: u0,u1,...  CBUFFER: cb0,cb1,...</c> )
	uint32_t    m_strideSize;      ///< The stride size in bytes for the regular buffers. If this is a constant buffer, the value for this member is set to the size of the constant buffer. 
	uint8_t     m_langType;        ///< The <c>PsslBufferType</c> such as <c>kBufferTypeDataBuffer</c>, <c>kBufferTypeTextureCubeArray</c>, etc.  
	uint8_t     m_internalType;    ///< The <c>PsslInternalBufferType</c> such as <c>kInternalBufferTypeUav</c>, <c>kInternalBufferTypeLds</c>, etc. 
	uint8_t     m_type;            ///< The <c>PsslType</c> such as <c>kTypeFloat4</c>, <c>kTypeFloat1x3</c>, etc.
	uint8_t     m_paddingTo32[1];  // 0; reserved for future use
	// for constant buffer 
	uint32_t    m_numElements;     ///< The number of elements if constant buffer. This is set 1 if the buffer has a template-type structure; otherwise it is set to 0.
	uint32_t    m_elementOffset;   ///< The shader binary offset to the beginning of elements in the elements block. This is set to 0xFFFFFFFF if there are none.

	uint32_t	m_nameOffset;      ///< The offset for the name of this binary buffer in the name string table.

	/// Gets the name of this binary buffer.
	///
	///	@return The name of this binary buffer.
	const char *getName() const { return ((const char*)&m_nameOffset) + m_nameOffset; }
};

/** Represents the shader binary sampler state. 

	The name and resource index are probably filled out by the compiler, but
	sample states in the PSSL source code are not currently stored.
*/
class SamplerState
{
public:
	uint32_t	m_statesToSetForLater[2]; ///< This field is 64bits and its use is TBD. 	
	uint32_t	m_resourceIndex;	      ///< The resource index.

	uint32_t	m_nameOffset;             ///< The offset for the name of this binary sampler state in the name string table.

	/// Gets the name of this binary sampler state.
	///
	///	@return The name of this binary sampler state.
	const char *getName() const { return ((const char*)&m_nameOffset) + m_nameOffset; }
};

/** Represents the shader binary pipeline stage. 

	Depending on the existence of the tessellation stage or geometry shader stage, 
	vertex and domain shaders become a different variant. 
	This union encapsulates this information.
*/
class PipelineStage
{
public:
	/// Represents vertex shader information.
	class VsInfo
	{
	public:
		uint8_t		m_vertexShaderVariant;	///< The <c>PsslVertexVariant</c> such as <c>kVertexVariantVertex</c>, <c>kVertexVariantExport</c>, <c>kVertexVariantLocal</c> etc.
		uint8_t		m_paddingTo32[3];		///< Padding.	
	};

	/// Represents domain shader information.
	class DsInfo
	{
	public:
		uint8_t		m_domainShaderVariant;	///< The <c>PsslDomainVariant</c> such as <c>kDomainVariantVertex</c>, <c>kDomainVariantExport</c> etc. 
		uint8_t		m_paddingTo32[3];		///< Padding.
	};

	/// Represents geometry shader information.
	class GsInfo
	{
	public:
		uint8_t		m_geometryShaderVariant;	///< The <c>PsslGeometryVariant</c> such as <c>kGeometryVariantOnBuffer</c>, <c>kGeometryVariantOnChip</c> etc. 
		uint8_t		m_paddingTo32[3];		///< Padding.
	};

	/// Represents geometry shader information.
	class HsInfo
	{
	public:
		uint8_t		m_hullShaderVariant;	///< The <c>PsslHullVariant</c> such as <c>kHullVariantOnBuffer</c>, <c>kHullVariantOnChip</c> etc. 
		uint8_t		m_paddingTo32[3];		///< Padding.
	};

	/// Stores data as different class types, depending on the type of shader. 
	union
	{
		uint32_t    m_u32;                  ///< An unsigned 32 bit integer. 
		VsInfo      m_vsInfo;				///< The vertex shader information. 
		DsInfo      m_dsInfo;				///< The domain shader information. 
		GsInfo      m_gsInfo;               ///< The geometry shader information.
		HsInfo      m_hsInfo;               ///< The hull shader information.
	};
};

/** Represents the shader binary system attributes. 

	For CS, GS, HS, and DS pipeline stages, extra system attributes are specified in the shader code.
	This class defines how this extra data is stored in the shader binary.
*/
class SystemAttributes
{
public:
	/// Represents CS pipeline stage information.
	class CsInfo
	{
	public:
		uint16_t	m_numThreads[3];        ///< The number of threads.
	};

	/// Represents GS pipeline stage information.
	class GsInfo
	{
	public:
		uint16_t	m_instance;				///< The instance of the GS Shader. 
		uint16_t	m_maxVertexCount;       ///< The maximum number of vertices count.
		uint8_t		m_inputType;            ///< The GS Input Type (<c>PsslGsIoType</c>) such as triangle, line, point, adjacent tri + line, or patch.
		uint8_t		m_outputType;           ///< The GS Output Type (<c>PsslGsIoType</c>) such as triangles, lines, or points.
		uint8_t		m_patchSize;	        ///< The patch size in case of patch topology.
	};

	/// Represents DS pipeline stage information.
	class DsInfo
	{
	public:
		uint8_t		m_domainPatchType;      ///< The <c>PsslHsDsPatchType</c>: triangle, quad, or isoline.  
		uint8_t		m_inputControlPoints;   ///< The number of points in the input patch.
	};

	/// Represents HS pipeline stage information.
	class HsInfo
	{
	public:
		uint8_t		m_domainPatchType;      ///< The <c>PsslHsDsPatchType</c>: triangle, quad, or isoline. 
		uint8_t		m_inputControlPoints;   ///< The number of points in the input patch.
		uint8_t		m_outputTopologyType;   ///< The <c>PsslHsTopologyType</c>: point, line, cwtri, or ccwtri.
		uint8_t		m_partitioningType;	    ///< The <c>PsslHsPartitioningType</c>: integer, powof2, odd_fractional, or even_fractional.

		uint8_t		m_outputControlPoints;  ///< The number of points in the output patch.
		uint8_t		m_patchSize; 		    ///< The size of patch.
		uint8_t		m_paddingTo32[2];       ///< Padding.

		float		m_maxTessFactor;        ///< The maximum tessellation factor.
	};
		
	/// Stores data as different class types, depending on the type of shader. 
	union 
	{
		uint32_t	m_u32[3];               ///< 12 bytes. 
		CsInfo      m_csInfo;               ///< The compute shader information.
		GsInfo      m_gsInfo;               ///< The geometry shader information.
		DsInfo      m_dsInfo;               ///< The domain shader information.
		HsInfo      m_hsInfo;               ///< The hull shader information.
	}; 
};

/** Represents the shader binary stream out. 

	The geometry shader has a mode to stream out resulted vertex data to the memory. 
	This class defines how the stream out configuration in the shader source code or 
	psslc command line options is stored in the shader binary.
*/
class StreamOut
{
public:
	uint16_t	m_stride;		         ///< The output buffer stride.
	uint16_t	m_offset;		         ///< The byte offset in the output buffer.
	
	uint8_t		m_semanticIndex;         ///< The semantic index of in StreamOut: 0, 1, etc. in TEXCOORD0,1.
	uint8_t		m_slot;		             ///< The output buffer slot.
	uint8_t		m_stream;		         ///< The stream ID to be written out.
	uint8_t		m_psslSemantic;	         ///< The <c>PsslSemantic</c> such as <c>kSemanticPosition</c>, <c>kSemanticSClipDistance</c>, etc.
	
	uint8_t		m_components;	         ///< The <c>PsslComponentMask</c> for this stream out. 
	uint8_t		m_paddingTo32[3];        ///< Padding.

	uint32_t	m_semanticNameOffset;    ///<  The offset for the name of this binary stream out in the name string table.

	/// Gets the name of this binary stream out.
	///
	///	@return The name of this binary stream out.
	const char *getSemanticName() const { return ((const char*)&m_semanticNameOffset) + m_semanticNameOffset; }
};

/** Represents the shader binary header. 

	The class includes basic information about the shader.
	This will be loaded into the runtime system first before the code and parameter information section
	of the shader binary.
*/
class Header 
{
public:
	uint8_t				m_formatVersionMajor;         ///< The version of shader binary format: major numbering. 
	uint8_t				m_formatVersionMinor;         ///< The version of shader binary format: minor numbering.
	uint16_t			m_compilerRevision;           ///< The compiler type specific version of shader compiler: this is the svn revision for m_compilerType==kCompilerTypeOrbisPsslc or kCompilerTypeOrbisEsslc or for kCompilerTypeUnspecified (pre-SDK 2.500 versions of these compilers)

	uint32_t			m_associationHash0;           ///< The shader association hash 1.
	uint32_t			m_associationHash1;           ///< The shader association hash 2.

	uint8_t				m_shaderType;                 ///< The <c>PsslShaderType</c>: VS, PS, GS, CS, GS, HS, or DS.
	uint8_t				m_codeType;                   ///< The <c>PsslCodeType</c>: IL, ISA, or SCU.
	uint8_t             m_usesShaderResourceTable;    ///< The shader uses resource table.
	uint8_t		    	m_compilerType		: 4;      ///< The <c>PsslCompilerType</c>; 0
	uint8_t				m_paddingTo32		: 4;      // 0; reserved for future use

	uint32_t			m_codeSize;                   ///< The size of code section.

	PipelineStage		m_shaderTypeInfo;             ///< The shader pipeline stage info.
	SystemAttributes	m_shaderSystemAttributeInfo;  ///< The shader system attribute info.
};

/** Represents the shader binary program.

	The order of the elements are consistent with the order of data in the shader binary file, 
	but the pointers in the class have to be initialized by using the loadFromMemory() function. 
	Once initialized, all data and various query functions become available.
*/
class Program
{
public:
	// binary program data chunk holder
	uint8_t*		m_dataChunk;              ///< The contiguous memory chunk that holds the program data.

	// shader program header and code
	Header*			m_header;  				  ///< The header for the shader program.  
	uint8_t*		m_code; 				  ///< This specifies whether the binary is an IL or ISA binary.

	// shader resource information section
	uint32_t		m_numBuffers;             ///< The number of buffer resources.           
	uint32_t		m_numConstants;			  ///< The number of binary constants.           
	uint32_t		m_numElements;   		  ///< The number of elements.           
	uint32_t		m_numSamplerStates;   	  ///< The number of sampler state resources.           
	uint8_t			m_numInputAttributes; 	  ///< The number of input attributes.           
	uint8_t			m_numOutputAttributes;	  ///< The number of output attributes.           
	uint8_t			m_numStreamOuts;      	  ///< The number of output streams.           
	uint8_t			m_paddingTo32; 			  ///< Padding.

	uint32_t		m_valueTableSize;   	  ///< The byte size of string table.
	uint32_t		m_stringTableSize;  	  ///< The byte size of value table

	Buffer*			m_buffers;				  ///< An array of buffer resources.	
	Constant*		m_constants; 			  ///< An array of binary constants.		
	Element*		m_elements;				  ///< An array of element resources.		
	SamplerState*	m_samplerStates; 		  ///< An array of sampler state resources.		 

	Attribute*		m_inputAttributes; 		  ///< An array of input attributes.	
	Attribute*		m_outputAttributes; 	  ///< An array of output attributes.	 

	StreamOut*		m_streamOuts;             ///< An array of geometry shader stream outputs.

	uint32_t*		m_valueTable;             ///< The table of default values.
	uint8_t*		m_stringTable;            ///< The table of symbol names.
														  
	// methods											  
	SCE_SHADER_BINARY_EXPORT               Program();
	SCE_SHADER_BINARY_EXPORT              ~Program();
	SCE_SHADER_BINARY_EXPORT uint32_t      calculateSize() const;
	SCE_SHADER_BINARY_EXPORT PsslStatus	 loadFromMemory( const void *shaderBinary, uint32_t shaderBinarySize );
	SCE_SHADER_BINARY_EXPORT PsslStatus	 saveToMemory( void* shaderBinary, uint32_t shaderBinarySize ) const;

	// Resource information query methods
	SCE_SHADER_BINARY_EXPORT Attribute    *getInputAttributeById( uint8_t attribIndex ) const; 
	SCE_SHADER_BINARY_EXPORT Attribute    *getOutputAttributeById( uint8_t attribIndex ) const; 

	SCE_SHADER_BINARY_EXPORT Attribute    *getInputAttributeBySemantic(PsslSemantic semantic) const;
	SCE_SHADER_BINARY_EXPORT Attribute    *getInputAttributeBySemanticNameAndIndex( const char *semanticName, uint8_t semanticIndex ) const;

	SCE_SHADER_BINARY_EXPORT Attribute    *getOutputAttributeBySemantic(PsslSemantic semantic) const;
	SCE_SHADER_BINARY_EXPORT Attribute    *getOutputAttributeBySemanticNameAndIndex( const char *semanticName, uint8_t semanticIndex ) const;
		
	SCE_SHADER_BINARY_EXPORT SamplerState *getSamplerStateByName( const char *samplerStateName ) const; 
	SCE_SHADER_BINARY_EXPORT Constant     *getConstantByName( const char *constantName ) const;
	SCE_SHADER_BINARY_EXPORT Buffer       *getBufferResourceByName( const char *bufferName ) const; 	

#ifdef SCE_SHADER_BINARY_ALLOW_DEPRECATED
	// Temporary solution for transitioning to the const versions, please don't use these
	SCE_SHADER_BINARY_EXPORT uint32_t      calculateSize();
	SCE_SHADER_BINARY_EXPORT PsslStatus	 saveToMemory( void* shaderBinary, uint32_t shaderBinarySize );
#endif

	//SCE_SHADER_BINARY_EXPORT Buffer       *getDefaultContantBuffer() const; // get constant buffer for global uniform variables
};

} // namespace Binary
} // namespace Shader
} // namespace sce

#endif // _SCE_SHADER_BINARY_H

