/* SIE CONFIDENTIAL
PlayStation(R)4 Programmer Tool Runtime Library Release 08.508.001
* Copyright (C) 2016 Sony Interactive Entertainment Inc.
*/
#pragma once

#if !defined(_SCE_GNMX_LWCUE_GRAPHICS_H)
#define _SCE_GNMX_LWCUE_GRAPHICS_H

#include "lwcue_base.h"

namespace sce
{
	namespace Gnmx
	{
			/** @brief Represents a Lightweight Constant Update Engine for the graphics context */
			class SCE_GNMX_EXPORT LightweightGraphicsConstantUpdateEngine : public BaseConstantUpdateEngine
			{
			public:

				/** @brief Initializes the resource areas for the Graphics constant updates.
				 *
				 *  @param[in] resourceBuffersInGarlic			An array of resource buffers to be used by the GraphicsCUE.
				 *  @param[in] resourceBufferCount				The number of resource buffers created.
				 *  @param[in] resourceBufferSizeInDwords		The size of each resource buffer.
				 *  @param[in] globalInternalResourceTableAddr	A pointer to the global resource table in memory.
				 */
				void init(uint32_t** resourceBuffersInGarlic, int32_t resourceBufferCount, uint32_t resourceBufferSizeInDwords, void* globalInternalResourceTableAddr);


				/** @brief Swaps LCUE's GraphicsCUE resource buffers for the next frame and invalidates all bindings. 
				 *
				 *  @note If <c>SCE_GNM_LCUE_CLEAR_HARDWARE_KCACHE</c> is enabled, any calls to swap buffers will additionally insert a command for flushShaderCachesAndWait() 
				 *        to invalidate both K$ and L2 caches.
				 *
				 *  @see DrawCommandBuffer::flushShaderCachesAndWait()
				 */
				void swapBuffers();


				/** @brief Clears all existing cached shaders, InputResourceOffsets table bindings, and dirty states. */
				void invalidateAllBindings();


				/** @brief Clears, for the specified shader stage, the existing cached shader plus InputResourceOffsets table bindings and dirty states.
				 *
				 *  @param[in] shaderStage The shader stage to invalidate.
				 *
				 *  @note After calling this function, it is required to rebind the cleared shader stage along with its InputResourceOffsets table.
				 * 
				 *	@see  LightweightGfxContext::setEmbeddedVsShader(), LightweightGfxContext::setEmbeddedPsShader()
				 */
				void invalidateShaderStage(sce::Gnm::ShaderStage shaderStage);


				/** @brief Sets the pointer to the draw command buffer.
				 *
				 *  @param[in] dcb A pointer to the draw command buffer.
				 */
				SCE_GNM_FORCE_INLINE void setDrawCommandBuffer(GnmxDrawCommandBuffer* dcb) { m_drawCommandBuffer = dcb; }


				/** @brief Sets the active shader stages in the graphics pipeline.
				 *
				 *  @param[in] activeStages Indicates which shader stages should be activated.
				 *	
				 *  @note By default, the setting of setGsMode is handled automatically  
				 *  by the Lightweight Constant Update Engine when <c><i>activeStages</i></c> is set to either kActiveShaderStagesEsGsVsPs or kActiveShaderStagesLsHsEsGsVsPs.
				 *  @see Gnm::DrawCommandBuffer::setGsMode()
				 */
				SCE_GNM_FORCE_INLINE void setActiveShaderStages(Gnm::ActiveShaderStages activeStages)
				{ 
					m_activeShaderStages = activeStages;
		
					// Changing GsMode rolls the hardware context, so just change it when it's really necessary
					bool geometryShaderActive = (activeStages == Gnm::kActiveShaderStagesEsGsVsPs)		 
												| (activeStages == Gnm::kActiveShaderStagesLsHsEsGsVsPs)
												| (activeStages == Gnm::kActiveShaderStagesOffChipLsHsEsGsVsPs)
												;

					if (m_gsMode != Gnm::kGsModeDisable && !geometryShaderActive)
					{
						m_drawCommandBuffer->disableGsMode();
						m_gsMode = Gnm::kGsModeDisable;
						m_gsMaxOutput = Gnm::kGsMaxOutputPrimitiveDwordSize1024;
						m_onChipGsSignature = LightweightConstantUpdateEngine::kOnChipGsInvalidSignature;
#if SCE_GNM_LCUE_ENABLE_UPDATE_SHADER
						m_dirtyShaderUpdateOnly[Gnm::kShaderStageGs] = false;
#endif // SCE_GNM_LCUE_ENABLE_UPDATE_SHADER
					}
				}


				/** @brief Binds an ES shader to the ES stage.
				 *
				 *  @param[in] shader				A Pointer to the ES shader.
				 *  @param[in] shaderModifier		The shader modifier value generated by generateEsFetchShaderBuildState(); specify a value 0 if there is no fetch shader.
				 *  @param[in] fetchShader			The GPU address of a fetch shader if one is required; otherwise specify a value of <c>NULL</c>.
				 *  @param[in] table				The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				void setEsShader(const sce::Gnmx::EsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a ES shader to the ES stage without a fetch shader.
				 *
				 *  @param[in] shader				A pointer to the ES shader.
				 *  @param[in] table				The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				SCE_GNM_FORCE_INLINE void setEsShader(const sce::Gnmx::EsShader* shader, const InputResourceOffsets* table) { setEsShader(shader, 0, NULL, table); }


				/** @brief Binds a ES shader to the ES stage.
				 *
				 *  @param[in] shader				A pointer to the ES shader.
				 *  @param[in] ldsSizeIn512Bytes	The LDS allocation size in 512-byte granularity allocation units. Internally, this value will be passed to
				 *									EsStageRegisters::updateLdsSize() before the EsShader is bound. If this parameter is 0, the function behaves
				 *									identically to ConstantUpdateEngine::setEsShader().
				 *
				 *  @param[in] shaderModifier		The shader modifier value generated by generateEsFetchShaderBuildState(); specify a value 0 if there is no fetch shader.
				 *  @param[in] fetchShader			The GPU address of a fetch shader if one is required; otherwise specify a value of <c>NULL</c>.
				 *  @param[in] table				The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note				Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note				This binding will not take effect on the GPU until preDraw() is called.
				 *  @note				This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be rebound.
				 *
				 *  @see Gnmx::computeOnChipGsConfiguration()
				 */
				void setOnChipEsShader(const Gnmx::EsShader *shader, uint32_t ldsSizeIn512Bytes, uint32_t shaderModifier, const void *fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a ES shader to the ES stage without a fetch shader.
				 *
				 *  @param[in] shader				A pointer to the ES shader.
				 *  @param[in] ldsSizeIn512Bytes	The LDS allocation size in 512-byte granularity allocation units. Internally, this value will be passed to
				 *									EsStageRegisters::updateLdsSize() before the EsShader is bound. If this parameter is 0, the function behaves
				 *									identically to ConstantUpdateEngine::setEsShader().
				 *  @param[in] table					The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note				Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note				This binding will not take effect on the GPU until preDraw() is called.
				 *  @note				This function must be called first before any resource bindings calls. If setEsShader() is called again, all resource bindings for the stage will need to be rebound.
				 *
				 *  @see Gnmx::computeOnChipGsConfiguration()
				 */
				SCE_GNM_FORCE_INLINE void setOnChipEsShader(const Gnmx::EsShader *shader, uint32_t ldsSizeIn512Bytes, const InputResourceOffsets* table) { setOnChipEsShader(shader, ldsSizeIn512Bytes, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the ES stage. Use for late fetch shader binding or updating the fetch shader.
				 *
				 *  @param[in] shaderModified		A shader modifier value generated by generateEsFetchShaderBuildState().
				 *  @param[in] fetchShader			A pointer to the fetch shader.
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*fetchShader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setEsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a GS shader to the GS and VS stages.
				 *
				 *  This function will roll the hardware context if any of the Gnm::GsStageRegisters entries set in the GsShader specified in <c>*shader</c>
				 *  or the Gnm::VsStageRegisters entries set for the copy shader specified in GsShader::getCopyShader() call to the shader specified in
				 *  <c>*shader</c> are different from current state:
				 *
				 *  Gnm::GsStageRegisters
				 *  - <c>m_vgtStrmoutConfig</c>
				 *  - <c>m_vgtGsOutPrimType</c>
				 *  - <c>m_vgtGsInstanceCnt</c>
				 *
				 *  Gnm::VsStageRegisters
				 *  - <c>m_spiVsOutConfig</c>
				 *  - <c>m_spiShaderPosFormat</c>
				 *  - <c>m_paClVsOutCntl</c>
				 * 
				 *  @param[in] shader		A pointer to a GS shader to bind to the GS/VS stages.
				 *  @param[in] table		The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setGsVsShaders() is called again, all resource bindings for the stage will need to be rebound.
				 */
				void setGsVsShaders(const sce::Gnmx::GsShader* shader, const InputResourceOffsets* table);
				
				
				/** @brief Binds an on-chip GS shader to the GS and VS stages and sets up the on-chip GS sub-group size controls.
				 * This function will roll hardware context.
				 *  @param[in] shader				A pointer to a GS shader to bind to the GS/VS stages.
				 *  @param[in] gsPrimsPerSubGroup	The number of GS threads which will be launched per on-chip-GS LDS allocation, which must be compatible with the size of LDS allocation passed to setOnChipEsShaders.
				 *  @param[in] table				The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note		Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note		This binding will not take effect on the GPU until preDraw() is called.
				 *  @note		This function must be called first before any resource bindings calls. If setGsVsShaders() is called again, all resource bindings for the stage will need to be rebound.
				 *  @note		In  SDK 3.5 only, a section of the setOnChipGsVsShaders() code calls setGsMode() before calling setGsOnChipControl(). This is incorrect and may cause a GPU hang.
				 *				If you use setOnChipGsVsShaders() in SDK 3.5, you must correct the source code to call setGsOnChipControl() then setGsMode() and rebuild the Gnmx library.
				 *				This bug is fixed in SDK 4.0. You do not need to implement this change when using SDK 4.0 or later.
				 *
				 *  @see Gnmx::computeOnChipGsConfiguration()
				 */
				void setOnChipGsVsShaders(const sce::Gnmx::GsShader* shader, uint32_t gsPrimsPerSubGroup, const InputResourceOffsets* table);

				
				/** @brief Sets the layout of LDS area where data will flow from the ES to the GS stages when on-chip geometry shading is enabled.
				 *
				 *  This sets the same context register state as <c>setEsGsRingBuffer(NULL, 0, maxExportVertexSizeInDword)</c>, but does not modify the global resource table.
				 *
				 *  This function will roll hardware context.
				 *
				 *  @param maxExportVertexSizeInDword		The stride of an ES-GS vertex in <c>DWORD</c>s, which must match EsShader::m_maxExportVertexSizeInDword.
				 *
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This binding requires setOnChipEsShader() be called prior to binding.
				 */
				SCE_GNM_FORCE_INLINE void setOnChipEsGsLdsLayout(uint32_t maxExportVertexSizeInDword)
				{
					setOnChipEsExportVertexSizeInDword((uint16_t)maxExportVertexSizeInDword);
					m_drawCommandBuffer->setupEsGsRingRegisters(maxExportVertexSizeInDword);
				}


				/** @brief Description to be specified
				 *
				 *  @param[in] onChipEsVertsPerSubGroup Number of vertices per subgroup.
				 *
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note Set internally by setOnChipGsVsShaders()
				 */
				void setOnChipEsVertsPerSubGroup(uint16_t onChipEsVertsPerSubGroup);

				
				/** @brief Specifies in <c>DWORD</c>s the size of vertices exported by the ES shader stage.
				 *
				 *  @param[in] onChipEsExportVertexSizeInDword The stride of an ES-GS vertex, expressed as a number of <c>DWORD</c>s.
				 *
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *
				 *  @see Gnmx::EsShader::m_memExportVertexSizeInDWord
				 */
				void setOnChipEsExportVertexSizeInDword(uint16_t onChipEsExportVertexSizeInDword);


				/** @brief Binds one or more streamout buffer objects to the specified shader stage.
				 *
				 *  @param[in] startSlot	The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxStreamOutBufferCount-1]</c>.     
				 *  @param[in] numSlots		The number of consecutive API slots to bind.
				 *  @param[in] buffers		The buffer objects to bind to the specified slots.
				 *						<c>buffers[0]</c> will be bound to <c><i>startSlot</i></c>, <c>buffers[1]</c> to <c>startSlot+1</c> and so on. 
				 *						The contents of these buffer objects are cached locally inside the LCUE's scratch buffer.
				 */
				void setStreamoutBuffers(int32_t startSlot, int32_t numSlots, const sce::Gnm::Buffer* buffers);


				/** @brief Binds a LS shader to the LS stage.
				 *
				 *  @param[in] shader				A pointer to the LS shader.
				 *  @param[in] shaderModifier		The shader modifier value generated by generateLsFetchShaderBuildState(); specify a value 0 if there is no fetch shader.
				 *  @param[in] fetchShader			The GPU address of a fetch shader if one is required; otherwise specify a value of <c>NULL</c>.
				 *  @param[in] table				The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setLsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				void setLsShader(const sce::Gnmx::LsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a LS shader to the LS stage without a fetch shader.
				 *
				 *  @param[in] shader				A pointer to the LS shader.
				 *  @param[in] table				The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setLsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				SCE_GNM_FORCE_INLINE void setLsShader(const sce::Gnmx::LsShader* shader, const InputResourceOffsets* table) { setLsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the LS stage. Use for late fetch shader binding or for updating the fetch shader.
				 *
				 *  @param[in] shaderModified			The shader Modifier value generated by generateLsFetchShaderBuildState().
				 *  @param[in] fetchShader				A pointer to the fetch shader.
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*fetchShader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setLsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a HS shader to the HS stage.
				 *
				 *  @param[in] shader Pointer to the HS shader.
				 *  @param[in] table			The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *  @param[in] tgPatchCount		The user desired patch count per thread group.
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setHsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				void setHsShader(const sce::Gnmx::HsShader* shader, const InputResourceOffsets* table, uint32_t tgPatchCount);

				/** @brief Binds an HS shader to the HS stage.
				 *
				 *  @param[in] shader Pointer to the HS shader.
				 *  @param[in] table			The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *  @param[in] tgPatchCount		The user desired patch count per thread group.
				 *  @param[in] distributionMode The tessellation distribution mode.
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setHsShader() is called again, all resource bindings for the stage will need to be rebound.
				 *  @note NEO mode only.
				 */
				void setHsShader(const Gnmx::HsShader* shader, const InputResourceOffsets* table, uint32_t tgPatchCount, Gnm::TessellationDistributionMode distributionMode);

				/** @brief Binds a VS shader to the VS stage.
				 * 
				 *  @param[in] shader			A pointer to the VS shader.
				 *  @param[in] shaderModifier	The shader modifier value generated by generateVsFetchShaderBuildState(); specify a value 0 if there is no fetch shader.
				 *  @param[in] fetchShader		The GPU address of a fetch shader if one is required; otherwise specify a value of <c>NULL</c>.
				 *  @param[in] table			The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*fetchShader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setVsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				void setVsShader(const sce::Gnmx::VsShader* shader, uint32_t shaderModifier, const void* fetchShader, const InputResourceOffsets* table);


				/** @brief Binds a VS shader to the VS stage without a fetch shader.
				 *
				 *  @param[in] shader			A pointer to the VS shader.
				 *  @param[in] table			The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setVsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				SCE_GNM_FORCE_INLINE void setVsShader(const sce::Gnmx::VsShader* shader, const InputResourceOffsets* table) { setVsShader(shader, 0, NULL, table); }


				/** @brief Binds a fetch shader separately for the VS shader stage. Use for late fetch shader binding or updating the fetch shader.
				 *
				 *  @param[in] shaderModified		The shader modifier value generated by generateVsFetchShaderBuildState().
				 *  @param[in] fetchShader			A pointer to the fetch shader.
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*fetchShader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 */
				void setVsFetchShader(uint32_t shaderModified, const void* fetchShader);


				/** @brief Binds a PS shader to the PS stage.
				 *
				 *  @param[in] shader		A Pointer to the PS shader.
				 *  @param[in] table		The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDraw() is called.
				 *  @note This function must be called first before any resource bindings calls. If setPsShader() is called again, all resource bindings for the stage will need to be rebound.
				 *  @note Passing <c>NULL</c> to this function does not disable pixel shading, by itself. The <c>shader</c> pointer may safely be <c>NULL</c> only if pixel shader invocation is
				 *       impossible, as is the case when:
				 *  	  - Color buffer writes have been disabled with <c>setRenderTargetMask(0)</c>.
				 *  	  - A CbMode other than <c>kCbModeNormal</c> is passed to <c>setCbControl()</c>, such as during a hardware MSAA resolve or fast-clear elimination pass.
				 *  	  - The depth test is enabled and <c>kCompareFuncNever</c> is passed to <c>DepthStencilControl::setDepthControl()</c>.
				 *  	  - The stencil test is enabled and <c>kCompareFuncNever</c> is passed to <c>DepthStencilControl::setStencilFunction()</c> and/or
				 *  	  	<c>DepthStencilControl::setStencilFunctionBack()</c>.
				 *  	  - Both front- and back-face culling are enabled with <c>PrimitiveSetup::setCullFace(kPrimitiveSetupCullFaceFrontAndBack)</c>.
				 *
				 */
				void setPsShader(const sce::Gnmx::PsShader* shader, const InputResourceOffsets* table);


				/** @brief Binds a CS shader to the CS stage.
				 *
				 *  @param[in] shader		A pointer to the CS shader.
				 *  @param[in] table		The matching InputResourceOffsets table created by generateShaderResourceOffsetTable().
				 *
				 *  @note Only the pointer is cached inside the LCUE; the location and contents of <c>*shader</c> must not change until the GPU has completed the draw!
				 *  @note This binding will not take effect on the GPU until preDispatch() is called.
				 *  @note This function must be called first before any resource bindings calls. If setCsShader() is called again, all resource bindings for the stage will need to be rebound.
				 */
				void setCsShader(const sce::Gnmx::CsShader* shader, const InputResourceOffsets* table);

				
				/** @brief Specifies a range of the Global Data Store to be used by shaders for atomic global counters such as those
				 *  used to implement PSSL <c>AppendRegularBuffer</c> and <c>ConsumeRegularBuffer</c> objects.
				 *
				 *  Each counter is a 32-bit integer. The counters for each shader stage may have a different offset in GDS. For example:
				 *  @code
				 *     setAppendConsumeCounterRange(kShaderStageVs, 0x0100, 12) // Set up three counters for the VS stage starting at offset 0x100.
				 *     setAppendConsumeCounterRange(kShaderStageCs, 0x0400, 4)  // Set up one counter for the CS stage at offset 0x400.
				 *	@endcode
				 *
				 *  The index is defined by the chosen slot in the PSSL shader. For example:
				 *  @code
				 *     AppendRegularBuffer<uint> appendBuf : register(u3) // Will access the fourth counter starting at the base offset provided to this function.
				 *  @endcode
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param[in] shaderStage				The shader stage to bind to this counter range.
				 *  @param[in] gdsMemoryBaseInBytes		The byte offset to the start of the counters in GDS. This must be a multiple of 4.
				 *  @param[in] countersSizeInBytes		The size of the counter range in bytes. This must be a multiple of 4.
				 *
				 *  @note GDS accessible size is provided by sce::Gnm::kGdsAccessibleMemorySizeInBytes. 
				 */
				void setAppendConsumeCounterRange(sce::Gnm::ShaderStage shaderStage, uint32_t gdsMemoryBaseInBytes, uint32_t countersSizeInBytes);


				/** @brief Specifies a range of the Global Data Store to be used by shaders.
				 *
				 *  This function never rolls the hardware context.
				 *
				 *  @param[in] stage				The shader stage to bind this range to.
				 *  @param[in] baseOffsetInBytes	The byte offset to the start of the range in GDS. This must be a multiple of 4. 
				 *  @param[in] rangeSizeInBytes		The size of the counter range in bytes. This must be a multiple of 4.
				 *
				 *  @note  GDS accessible size is provided by sce::Gnm::kGdsAccessibleMemorySizeInBytes. It is an error to specify a range outside these bounds.
				 */
				void setGdsMemoryRange(sce::Gnm::ShaderStage stage, uint32_t baseOffsetInBytes, uint32_t rangeSizeInBytes);

				
				/** @brief Binds one or more constant buffer objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage	The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxConstantBufferCount-1]</c>.
				 *  @param[in] apiSlotCount The number of consecutive API slots to bind.
				 *  @param[in] buffer		A pointer to the buffer(s).	
				 */
				void setConstantBuffers(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more vertex buffer objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage		The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot		The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxVertexBufferCount-1]</c>.
				 *  @param[in] apiSlotCount		The number of consecutive API slots to bind.
				 *  @param[in] buffer			The constant buffer objects to bind to the specified slots. <c>buffer[0]</c> will be bound to <c><i>startApiSlot</i></c>, <c>buffer[1]</c> to <c><i>startApiSlot</i>+1</c>, and so on.
				 *					The contents of these buffer objects are cached locally inside the LCUE's scratch buffer.
				 * 					This value must not be <c>NULL</c>.
				 */
				void setVertexBuffers(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read-only buffer objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage			The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot			The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxResourceCount-1]</c>.
				 *  @param[in] apiSlotCount			The number of consecutive API slots to bind.
				 *  @param[in] buffer				The buffer objects to bind to the specified slots. <c>buffer[0]</c> will be bound to <c><i>startApiSlot</i></c>, <c>buffer[1]</c> to <c><i>startApiSlot</i>+1</c>, and so on.
				 *									The contents of these buffer objects are cached locally inside the LCUE's scratch buffer.
				 *
				 *  @note These Buffers and Textures share the same pool of API slots.
				 */
				void setBuffers(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read/write buffer objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage			The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot			The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxRwResourceCount-1]</c>.
				 *  @param[in] apiSlotCount			The number of consecutive API slots to bind.
				 *  @param[in] buffer				The read/write buffer objects to bind to the specified slots. <c>buffer[0]</c> will be bound to <c><i>startApiSlot</i></c>, <c>buffer[1]</c> to <c><i>startApiSlot</i>+1</c>, and so on.
				 *									The contents of these buffer objects are cached locally inside the LCUE's scratch buffer.
				 *
				 *  @note Read/write buffers and read/write textures share the same pool of API slots.
				 */
				void setRwBuffers(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Buffer* buffer);


				/** @brief Binds one or more read-only texture objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage		The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot		The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxResourceCount-1]</c>.
				 *  @param[in] apiSlotCount		The number of consecutive API slots to bind.
				 *  @param[in] texture			The texture objects to bind to the specified slots. <c>texture[0]</c> will be bound to <c><i>startApiSlot</i></c>, <c>texture[1]</c> to <c><i>startApiSlot</i>+1</c>, and so on.
				 *					The contents of these texture objects are cached locally inside the LCUE's scratch buffer.
				 *
				 *  @note Buffers and Textures share the same pool of API slots.
				 */
				void setTextures(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Texture* texture);


				/** @brief Binds one or more read/write texture objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage		The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot		The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxRwResourceCount-1]</c>.
				 *  @param[in] apiSlotCount		The number of consecutive API slots to bind.
				 *  @param[in] texture			The read/write texture objects to bind to the specified slots. <c>texture[0]</c> will be bound to <c><i>startApiSlot</i></c>, <c>texture[1]</c> to <c><i>startApiSlot</i>+1</c>, and so on.
				 *					The contents of these texture objects are cached locally inside the LCUE's scratch buffer.
				 *					This value must not be <c>NULL</c>.
				 *  @note Read/write buffers and read/write textures share the same pool of API slots.
				 */
				void setRwTextures(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Texture* texture);


				/** @brief Binds one or more sampler objects to the specified shader stage.
				 *
				 *  @param[in] shaderStage		The shader stage to which this function binds one or more resources.
				 *  @param[in] startApiSlot		The first API slot to bind to. Valid slots are <c>[0..LCUE::kMaxSamplerCount-1]</c>.
				 *  @param[in] apiSlotCount		The number of consecutive API slots to bind.
				 *  @param[in] sampler			The Sampler objects to bind to the specified slots. <c>sampler[0]</c> will be bound to <c><i>startApiSlot</i></c>, <c>sampler[1]</c> to <c><i>startApiSlot</i>+1</c>, and so on. 
				 *  							The contents of these Sampler objects are cached locally inside the LCUE's scratch buffer.
				 *  
				 */
				void setSamplers(sce::Gnm::ShaderStage shaderStage, uint32_t startApiSlot, uint32_t apiSlotCount, const sce::Gnm::Sampler* sampler);


				/** @brief Binds an SRT buffer to the specified shader stage.
				 *
				 *  @param[in] shaderStage	The shader stage to bind to the SRT buffer.
				 *  @param[in] buffer		The pointer to the buffer. If <c>NULL</c>, <c><i>bufSizeInDwords</i></c> must be <c>0</c>.
				 *  @param[in] sizeInDwords	The size of the data pointed to by <c><i>buffer</i></c> in <c>DWORD</c>s. The valid range is <c>[1..kMaxSrtUserDataCount]</c> if <c><i>buffer</i></c> is non-<c>NULL</c>.
				 */
				void setUserSrtBuffer(sce::Gnm::ShaderStage shaderStage, const void* buffer, uint32_t sizeInDwords);


				/** @brief Executes all previous enqueued resource and shader bindings in preparation for a draw call.
				 *
				 *  This function may roll the hardware context.
				 *
				 *  Dirty resource bindings will be flushed from the internal scratch buffer and committed to the resource buffer
				 *
				 *  @note When using the Lightweight Constant Update Engine to manage shaders and shader resources, this function must be called 
				 *		  immediately before every draw call.
				 *  @note To minimize context rolls by preDraw(), avoid calling shader-binding stages {Vs, Ps, Hs, Gs}
				 *		  redundantly between consecutive preDraw() calls. To reduce context rolls further, it is also advisable to disable <c>SCE_GNM_LCUE_ENABLE_UPDATE_SHADER</c> 
				 *		  and bind the PsShaderUsage table manually.
				 */
				void preDraw();

				
				/** @brief Executes all previous enqueued resource and shader bindings in preparation for a dispatch call.
				 *
				 *  Dirty resource bindings will be flushed from the internal scratch buffer and committed to the resource buffer
				 *
				 *  @note When using the Lightweight Constant Update Engine to manage shaders and shader resources, this function must be called 
				 *		  immediately before every draw call.
				 */
				void preDispatch();


				/**
				* @brief Returns the DispatchOrderedAppendMode setting that the currently set graphics pipe CS shader requires.
				*
				* @return The DispatchOrderedAppendMode setting that the currently set graphics pipe CS shader requires. If non-zero, you must call DrawCommandBuffer::dispatchWithOrderedAppend().
				*/
				Gnm::DispatchOrderedAppendMode getCsShaderOrderedAppendMode() const { return (Gnm::DispatchOrderedAppendMode)m_gfxCsShaderOrderedAppendMode; }


				/** @brief Sets the vertex and instance offset for the current shader configuration.
				 *
				 *  The vertex and instance offsets work only when enabled in the vertex shader.
				 *
				 *  @param[in] vertexOffset		The offset added to each vertex index.
				 *  @param[in] instanceOffset	The offset added to instance index.
				 */
				void setVertexAndInstanceOffset(uint32_t vertexOffset, uint32_t instanceOffset);


				/** @brief Checks if the current shader configuration is expecting a vertex or instance offset.
				 */
				bool isVertexOrInstanceOffsetEnabled() const;


				/** @brief Gets a pointer to the currently bound shader at the specified shader stage.
				 *
				 *  @param[in] shaderStage	The shader stage for which this function returns a pointer.
				 *
				 *  @return A pointer to the bound shader.
				 */
				SCE_GNM_FORCE_INLINE const void* getBoundShader(sce::Gnm::ShaderStage shaderStage){ return m_boundShader[shaderStage]; }


				/** @brief Gets the last value set using setActiveShaderStages()
				 *
				 *  @return The shader stages that will be considered activated by preDraw() calls.
				 */
				SCE_GNM_FORCE_INLINE Gnm::ActiveShaderStages getActiveShaderStages(){ return m_activeShaderStages; }


				/** @brief Sets the pixel shader input usage table.
				 *
				 *  @param[in] psInput The pixel shader input usage table to set for up coming draw calls.
				 *
				 *  @note This function should be called after calls to setPsShader() and setVsShader().
				 *        Calls to setPsShader() or setVsShader() will invalidate the currently bound table.
				 *        If not specified, an appropriate table will be auto-generated in preDraw().
				 */
				SCE_GNM_FORCE_INLINE void setPsInputUsageTable(const uint32_t *psInput){ m_psInputsTable = psInput; }


				/** @brief Enables/disables automatic generation and binding of the reserved tessellation constant buffer.
				 *
				 *	@param[in] enable	A flag that specifies whether to enable automatic generation and binding of the reserved tessellation constant buffer
		 		 *
				 *	@note This feature is enabled by default.
 				 */
				SCE_GNM_FORCE_INLINE void setTessellationAutoManageReservedCBEnable(bool enable){ m_tessellationAutoManageReservedCb = enable; }


				/** @brief Sets tessellation off-chip factor threshold for dynamic hull and domain shaders.
				 * 
				 *  @param[in] offChipFactorThreshold The threshold for the sum of tessellation factors to go off-chip in a dynamic shader.
				 *
				 *	@note  NEO mode only.
				 *  @note  If preDrawTessellation() is called, the LCUE uses offChipFactorThreshold when binding the Gnm::TessellationDataConstantBuffer.
				 */
				SCE_GNM_FORCE_INLINE void setTessellationOffChipFactorThreshold(float offChipFactorThreshold){ m_tessellationCurrentOffChipFactorThreshold = offChipFactorThreshold; }


	#if !defined(DOXYGEN_IGNORE)

				SCE_GNM_LCUE_NOT_SUPPORTED
				void setInternalSrtBuffer(sce::Gnm::ShaderStage shaderStage, const void* buffer){ SCE_GNM_UNUSED(shaderStage); SCE_GNM_UNUSED(buffer);};

			public:
				uint32_t							m_scratchBuffer[LightweightConstantUpdateEngine::kGraphicsScratchBufferSizeInDwords];

				GnmxDrawCommandBuffer*		        m_drawCommandBuffer;
				

				// Each active shader stage has a pointer to inside the buffer where it should place its resources according to the offset table
				const void*					m_boundShader[LightweightConstantUpdateEngine::kNumShaderStages];
				uint32_t					m_boundShaderAppendConsumeCounterRange[LightweightConstantUpdateEngine::kNumShaderStages];
				uint32_t					m_boundShaderGdsMemoryRange[LightweightConstantUpdateEngine::kNumShaderStages];
				const void*					m_boundFetchShader[LightweightConstantUpdateEngine::kNumShaderStages];			// Only for LS, ES, VS
				uint32_t					m_boundShaderModifier[LightweightConstantUpdateEngine::kNumShaderStages];		// Only for LS, ES, VS
				const InputResourceOffsets* m_boundShaderResourceOffsets[LightweightConstantUpdateEngine::kNumShaderStages];

				const uint32_t*	m_psInputsTable;
				uint32_t m_cachedPsInputTable[LightweightConstantUpdateEngine::kMaxPsInputUsageCount];
				uint32_t m_dirtyCachedPsInputTable;
				
				bool m_dirtyShader[LightweightConstantUpdateEngine::kNumShaderStages];				// Track whether a new shader has to be bound to the DCB
				bool m_dirtyShaderResources[LightweightConstantUpdateEngine::kNumShaderStages];		// Track whether shader resources needs to be updated
				bool m_dirtyShaderUpdateOnly[LightweightConstantUpdateEngine::kNumShaderStages];	// Track whether a shader only has to be updated to reduce context rolls (Only for PS, VS, GS and HS)

				
				Gnm::ActiveShaderStages	m_activeShaderStages;
				
				uint16_t		m_updateShaderBindingIsValid;
				uint16_t		m_shaderBindingIsValid;


				// Geometry Shader
				InputResourceOffsets m_fixedGsVsShaderResourceOffsets;					// Fixed offset table for the VS Copy shader for Geometry pipeline
				InputResourceOffsets m_fixedGsVsStreamOutShaderResourceOffsets;			// Fixed offset table for the VS Copy shader for Geometry pipeline with stream out
				InputResourceOffsets m_fixedOnChipGsVsShaderResourceOffsets;			// Fixed offset table for the on chip VS Copy shader for Geometry pipeline
				InputResourceOffsets m_fixedOnChipGsVsStreamOutShaderResourceOffsets;	// Fixed offset table for the on chip VS Copy shader for Geometry pipeline with stream out

				Gnm::GsMode m_gsMode;												// Last tracked GsMode
				Gnm::GsMaxOutputPrimitiveDwordSize m_gsMaxOutput;					// Last tracked GsMaxOutputPrimitiveDwordSize

				uint8_t							m_gfxCsShaderOrderedAppendMode;
				uint8_t							m_pad0[3];

				// GS/ES on-chip controls
				uint32_t	m_onChipLdsSizeIn512Bytes;
				uint16_t	m_onChipEsVertsPerSubGroup;
				uint16_t	m_onChipEsExportVertexSizeInDword;
				uint32_t	m_onChipGsSignature;

				// Tessellation controls
				Gnm::TessellationRegisters	m_tessellationCurrentRegs;
				uint32_t					m_tessellationCurrentTgPatchCount;
				Gnm::Buffer					m_tessellationCurrentCb;
				uint32_t					m_tessellationCurrentDistributionMode;
				float						m_tessellationCurrentOffChipFactorThreshold;
				uint8_t m_pad1[2];

				bool		m_tessellationAutoManageReservedCb;

				mutable LightweightConstantUpdateEngine::ShaderResourceBindingValidation m_boundShaderResourcesValidation[LightweightConstantUpdateEngine::kNumShaderStages];

				uint8_t m_pad2[8];

			public:

				SCE_GNM_FORCE_INLINE uint32_t* flushScratchBuffer(uint8_t shaderStage);
				SCE_GNM_FORCE_INLINE void updateOnChipParametersInUserDataSgprs(sce::Gnm::ShaderStage shaderStage);
				SCE_GNM_FORCE_INLINE void updateLsEsVsPtrsInUserDataSgprs(sce::Gnm::ShaderStage shaderStage, const uint32_t* resourceBufferFlushedAddress);
				SCE_GNM_FORCE_INLINE void updateCommonPtrsInUserDataSgprs(sce::Gnm::ShaderStage shaderStage, const uint32_t* resourceBufferFlushedAddress);
				SCE_GNM_FORCE_INLINE void updateEmbeddedCb(sce::Gnm::ShaderStage shaderStage, const sce::Gnmx::ShaderCommonData* shaderCommon);
				SCE_GNM_FORCE_INLINE void setOrUseCachedPsInputUsageTable(const uint32_t *psInput, uint32_t numInputSemantics);

				void preDrawTessellation(bool geometryShaderEnabled);
				void preDrawGeometryShader();

				void setUserData(sce::Gnm::ShaderStage shaderStage, uint32_t startSgpr, uint32_t sgprCount, const uint32_t* data);
				void setPtrInUserData(sce::Gnm::ShaderStage shaderStage, uint32_t startSgpr, const void* gpuAddress);

	#endif // !defined(DOXYGEN_IGNORE)
			};
	} // Gnmx
} // sce


#endif // _SCE_GNMX_LWCUE_GRAPHICS_H
